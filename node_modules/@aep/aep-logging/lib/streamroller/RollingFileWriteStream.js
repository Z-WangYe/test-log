const debug = require("debug")("streamroller:RollingFileWriteStream");
const fse = require("fs-extra");
const path = require("path");
const newNow = require("./now");
const fs = require('fs')
const format = require("date-format");
const { Writable } = require("stream");
const fileNameFormatter = require("./fileNameFormatter");
const fileNameParser = require("./fileNameParser");
const moveAndMaybeCompressFile = require("./moveAndMaybeCompressFile");
/**
 * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.
 * RollingFileWriteStream inherits from stream.Writable
 */
class RollingFileWriteStream extends Writable {
    /**
     * Create a RollingFileWriteStream
     * @constructor
     * @param {string} filePath - The file path to write.
     * @param {object} options - The extra options
     * @param {number} options.numToKeep - The max numbers of files to keep.
     * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.
     *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.
     * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.
     * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.
     * @param {boolean} options.compress - Whether to compress backup files.
     * @param {boolean} options.keepFileExt - Whether to keep the file extension.
     * @param {string} options.pattern - The date string pattern in the file name.
     * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.
     */
    constructor(filePath, options) {
        debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
        super(options);
        this.options = this._parseOption(options);
        this.filePath = filePath
        this.fileObject = path.parse(filePath);
        if (this.fileObject.dir === "") {
            this.fileObject = path.parse(path.join(process.cwd(), filePath));
        }
        this.fileFormatter = fileNameFormatter({
            file: this.fileObject,
            alwaysIncludeDate: this.options.alwaysIncludePattern,
            needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
            compress: this.options.compress,
            keepFileExt: this.options.keepFileExt,
            folderDate: this.options.folderDate
        });
        this.fileNameParser = fileNameParser({
            file: this.fileObject,
            keepFileExt: this.options.keepFileExt,
            pattern: this.options.pattern
        });
        this.state = {
            currentSize: 0
        };
        if (this.options.pattern) {
            this.state.currentDate = format(this.options.pattern, newNow());
        }
        if (this.options.folderDate && !this.options.pattern) {
            this.state.currentFoldDate = format(this.options.folderDate, newNow());
        }
        this.filename = this.fileFormatter({
            index: 0,
            date: this.state.currentDate || format(this.options.folderDate, newNow())
        });
        if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
            this._setExistingSizeAndDate();
        }
        debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
    }
    _setExistingSizeAndDate() {
        try {
            const stats = fs.statSync(this.filename);
            this.state.currentSize = stats.size;
            if (this.options.pattern) {
                this.state.currentDate = format(this.options.pattern, stats.mtime);
            }
        }
        catch (e) {
            //file does not exist, that's fine - move along
            return;
        }
    }
    _parseOption(rawOptions) {
        const defaultOptions = {
            maxSize: Number.MAX_SAFE_INTEGER,
            numToKeep: Number.MAX_SAFE_INTEGER,
            encoding: "utf8",
            mode: 0o765,
            flags: "a",
            compress: false,
            keepFileExt: false,
            alwaysIncludePattern: false
        };
        const options = Object.assign({}, defaultOptions, rawOptions);
        if (options.maxSize <= 0) {
            throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
        }
        if (options.numToKeep <= 0) {
            throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
        }
        debug(`_parseOption: creating stream with option=${JSON.stringify(options)}`);
        return options;
    }
    _final(callback) {
        this.currentFileStream.end("", this.options.encoding, callback);
    }
    _write(chunk, encoding, callback) {
        this._shouldRoll().then(() => {
            // if (!this.currentFileStream) {
            //     const ops = {
            //         flags: this.options.flags,
            //         encoding: this.options.encoding,
            //         mode: this.options.mode,
            //         // fd: 2
            //     };
            //     this.currentFileStream = fs.createWriteStream(this.filePath, ops);
            // }
            debug(`_write: writing chunk. ` +
                `file=${this.filePath} ` +
                `state=${JSON.stringify(this.state)} ` +
                `chunk=${chunk}`);
            // fs.appendFileSync(this.filePath, chunk, { encoding: 'utf8' })
            // this.state.currentSize += chunk.length;
            // callback();
            this.currentFileStream.write(chunk, encoding, e => {
                this.state.currentSize += chunk.length;
                callback(e);
            });
            // this.currentFileStream.end();
            // this.currentFileStream = null;

        });
    }
    async _shouldRoll() {
        if (this._dateChanged() || this._tooBig()) {
            // if (true) {
            debug(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);
            await this._roll();
        }
    }
    _dateChanged() {
        if (this.options.folderDate) {
            if (this.state.currentFoldDate) {
                const retval = this.state.currentFoldDate !== format(this.options.folderDate, newNow());
                this.state.currentFoldDate = format(this.options.folderDate, newNow());
                return retval;
            }
        }
        return (this.state.currentDate &&
            this.state.currentDate !== format(this.options.pattern, newNow()));
    }
    _tooBig() {
        return this.state.currentSize >= this.options.maxSize;
    }
    _roll() {
        debug(`_roll: closing the current stream`);
        return new Promise((resolve, reject) => {
            this.currentFileStream.end("", this.options.encoding, () => {
                this._moveOldFiles()
                    .then(resolve)
                    .catch(reject);
            });
        });
    }
    async _moveOldFiles() {
        const files = await this._getExistingFiles();
        const todaysFiles = this.state.currentDate
            ? files.filter(f => f.date === this.state.currentDate)
            : files;
        for (let i = todaysFiles.length; i >= 0; i--) {
            debug(`_moveOldFiles: i = ${i}`);
            const sourceFilePath = this.fileFormatter({
                date: this.state.currentDate || this.state.currentFoldDate,
                index: i
            });
            const targetFilePath = this.fileFormatter({
                date: this.state.currentDate || this.state.currentFoldDate,
                index: i + 1
            });
            await moveAndMaybeCompressFile(sourceFilePath, targetFilePath, this.options.compress && i === 0);
        }
        this.state.currentSize = 0;
        this.state.currentDate = this.state.currentDate
            ? format(this.options.pattern, newNow())
            : null;
        debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
        // wait for the file to be open before cleaning up old ones,
        // otherwise the daysToKeep calculations can be off
        await new Promise((resolve, reject) => {
            this.currentFileStream.write("", "utf8", () => {
                this._clean()
                    .then(resolve)
                    .catch(reject);
            });
        });
    }
    // Sorted from the oldest to the latest
    async _getExistingFiles() {
        const files = await fs.readdir(this.fileObject.dir).catch(() => []);
        debug(`_getExistingFiles: files=${files}`);
        const existingFileDetails = files
            .map(n => this.fileNameParser(n))
            .filter(n => n);
        const getKey = n => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
        existingFileDetails.sort((a, b) => getKey(a) - getKey(b));
        return existingFileDetails;
    }
    async _getExistingDirs() {
        const dir = path.parse(this.options.filename).dir;
        const files = await fs.readdir(dir).catch(() => []);
        const dirs = files.filter((file) => {
            return fs.lstatSync(path.join(dir, file)).isDirectory();
        });
        debug(`_getExistingDirs: dirs=${dirs}`);
        const _getExistingDirs = dirs;
        const getKey = n => {
            const date = format.parse(this.options.folderDate, n, new Date(0, 0));
            const timestamp = date.getTime();
            return timestamp;
        };
        _getExistingDirs.sort((a, b) => getKey(a) - getKey(b));
        return _getExistingDirs;
    }
    _renewWriteStream() {
        const filePath = this.fileFormatter({
            date: format(this.options.folderDate, newNow()),
            index: 0
        });
        this.fileObject = path.parse(filePath);
        fse.ensureDirSync(this.fileObject.dir);
        const ops = {
            flags: this.options.flags,
            encoding: this.options.encoding,
            mode: this.options.mode,
            // fd: 2
        };
        console.log("filePath", filePath)
        // fse.ensureFileSync(filePath);
        // fs.chmod(filePath, 0o765, (err) => {
        //     if (err) throw err;
        //     console.log('The permissions for file "my_file.txt" have been changed!');
        // });
        this.currentFileStream = fs.createWriteStream(filePath, ops);

        this.currentFileStream.on("error", e => {
            this.emit("error", e);
        });
    }
    async _clean() {
        const existingFileDetails = await this._getExistingFiles();
        debug(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);
        debug("_clean: existing files are: ", existingFileDetails);
        if (this._tooManyFiles(existingFileDetails.length)) {
            const fileNamesToRemove = existingFileDetails
                .slice(0, existingFileDetails.length - this.options.numToKeep - 1)
                .map(f => path.format({ dir: this.fileObject.dir, base: f.filename }));
            await deleteFiles(fileNamesToRemove);
        }
        if (this.options.folderDate) {
            const existingDirDetails = await this._getExistingDirs();
            if (this._tooManyDirs(existingDirDetails.length)) {
                const dirNamsToRemove = existingDirDetails
                    .slice(0, existingDirDetails.length - this.options.daysToKeep - 1)
                    .map(f => path.join(path.parse(this.options.filename).dir, f));
                await deleteDirs(dirNamsToRemove);
            }
        }
    }
    _tooManyFiles(numFiles) {
        return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
    }
    _tooManyDirs(numFiles) {
        return this.options.daysToKeep > 0 && numFiles > this.options.daysToKeep;
    }
}
const deleteFiles = fileNames => {
    debug(`deleteFiles: files to delete: ${fileNames}`);
    return Promise.all(fileNames.map(f => fs.unlink(f).catch((e) => {
        debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
    })));
};
const deleteDirs = async (dirs) => {
    return Promise.all(dirs.map(f => fs.rmSync(f).catch((e) => {
        debug(`deleteDirs: error when unlinking ${f}, ignoring. Error was ${e}`);
    })));
};
module.exports = RollingFileWriteStream;
//# sourceMappingURL=RollingFileWriteStream.js.map